<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>How Colluding Sites can Identify You</title>
  <meta name="description" content="How Colluding Sites can Identify You">
  <meta name="author" content="idk">

  <link rel="stylesheet" href="/css/styles.css">

</head>

<body>

<h1>How Colluding Sites can Identify You</h1>

<p>This is a dangerous web site! In fact, pretty much all web sites are
dangerous in theory. But this one's about the theory, so that makes it even
more dangerous. It's intended to provide more information about already public
information, suggest a change, and not to cause harm or alarm. I don't think
you should use this information to do bad things to i2p users or the i2p
network. Only click on the links on this page if you're curious about the
matter of your i2p client tunnel destinationss. Also, for the record,
<strong>this page </strong> is not recording any headers or logs of any kind,
it's generated and hosted by the code hosted in
https://github.com/eyedeekay/colluding_sites_attack. This is a transparent
service for educational purposes only. </p>

<h2>What does Identification mean in this context</h2>

<p>By "Identification" I mean any characteristic which remains consistent in
spite of what destination you are connected to, in particular, this is the
normal operation of the i2p http proxy included with i2p and i2pd(presumably
kovri as well if it has an http proxy). It's just a fact that in order to
request a resource for retrieval, you have to provide an address to return
that resource to. The http proxy is intended to do this in a very basic way,
you get a destination when i2p starts up, and it's torn down when it shuts down.
But while it's up, the destination stays the same. This is the normal operation
of i2p, it's documented, and it's not because anyone's a bad person. It's
because it's a demonstration of the network's functionality and I don't think
that, necessarily, the i2p core developers need to do anything in the core about
it. But I'll get to that in a second.</p>

<h2>This attack does not, in and of itself, reveal your real IP Address* or
any other marker thought to correspond to a real-life identity or location or
context. Perish the thought.</h2>

<h3>*However, if you viit the sites linked below, a variety of attacks will be
carried out against your browser and your https proxy, one of which can reveal
the IP address of an improperly configured browser and there's nothing the proxy
can do about this. Make sure to always check [*] Use this proxy for all
connections in Firefox. This is the default in surf and uzbl. I don't know about
Chrome or IE. Don't click the links. They are here for me to test my software.<h3>

<p>Because the tunnel is consistent across remote destinations, and because it
has a useful lifespan, it could be used to identify traffic by someone running
a network of colluding eepSites. If someone were using the default http proxy to
use a centralized social network on i2p(Like, a maliciously modified mastodon
instance or something), that could be used to build a profile of that person
across renewed http proxy destinations. Every time you log in to that mastodon
instance, your new http proxy destination becomes linked to the old one. God
forbid if there's ever a facebook.i2p(remember, bypassing censorship and
obfuscating location are valuable even without anonymity). So that's probably
not a big deal right now, if most people on i2p are not participating in those
kinds of social network directly, but it's present. It's pretty boring, it's not
a bug, but it's present. Heck, it was even brought to my attention by someone
else. I just made a demo after I was mostly done fabricating a solution because
I needed to test it.</p>

<h2>Furthermore, it's actually pretty useful to have destination tunnels with
user-controlled lifespans</h2>

<p>In fact, a long-term cryptographic destination is exactly the thing that
allows you to host a hidden service. It's just that, with core i2p and i2pd, you
have to manually separate your contextual identities.</p>

<h3>X-I2P-Dest* Fingerprinting Demos</h3>

<ul>
<li><a href="http://4pvyyb3phqznc6e6fjewty2fpbb4p3ub2q27ojheitcg4nai6p5q.b32.i2p">This site:</a> </li>
<li><a href="http://lqnwvwsgio6k53zq6d7r5bpaxuslc45vgsiqo6i3ebshkqpgrnma.b32.i2p">Fingerprinting Site 1:</a> </li>
<li><a href="http://zcofypupen75rdv5zihviweyw5emk2l34idq423kbhj7n3owoe5a.b32.i2p">Fingerprinting Site 2:</a></li>
<li><a href="http://zjjjd756aucwz3pa2fl4mb3po2wtf752aefpod4gvedwreeox52q.b32.i2p">Fingerprinting Site 3:</a></li>
</ul>

<h3>The service code:</h3>

<p>This is the code to the services behind those links, which will reveal your
unique i2p destination.</p>

<pre><code>    package main

    import (
        "flag"
        "fmt"
        "log"
        "math/rand"
        "net/http"
        "time"
    )

    import "github.com/eyedeekay/sam-forwarder"

    type blah struct{}

    var forwarder *samforwarder.SAMForwarder

    var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

    func randSeq(n int) string {
        b := make([]rune, n)
        for i := range b {
            b[i] = letters[rand.Intn(len(letters))]
        }
        return string(b)
    }

    func (b *blah) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        log.Println("the echo service is responding to a request on:", forwarder.Base32())
        fmt.Fprintf(w, "<!DOCTYPE html>\n")
        fmt.Fprintf(w, "<html>\n")
        fmt.Fprintf(w, "<head>\n")
        fmt.Fprintf(w, "  <title> What is my Base64? </title>\n")
        fmt.Fprintf(w, "  <link rel=\"stylesheet\" href=\"http://4pvyyb3phqznc6e6fjewty2fpbb4p3ub2q27ojheitcg4nai6p5q.b32.i2p/css/styles.css\">\n")
        fmt.Fprintf(w, "</head>\n")
        fmt.Fprintf(w, "  <body>\n")
        fmt.Fprintf(w, "  <p>\n")
        fmt.Fprintf(w, "    Attempting to force resource retrieval over plain https")
        fmt.Fprintf(w, "  </p>\n")
        fmt.Fprintf(w, "    <pre><code>\n")
        for key, value := range r.Header {
            log.Println(key, value)
            fmt.Fprintf(w, "Header: %s, Value: %s\n", key, value)
        }
        fmt.Fprintf(w, "    </pre></code>\n")
        fmt.Fprintf(w, "  <script type=\"application/javascript\">\n")
        fmt.Fprintf(w, "    function getIP(json) {\n")
        fmt.Fprintf(w, "      document.write(\"<pre><code>\");\n")
        fmt.Fprintf(w, "      document.write(\"My public IP address is:\", json.ip);\n")
        fmt.Fprintf(w, "      document.write(\"</pre></code>\");\n")
        fmt.Fprintf(w, "    }\n")
        fmt.Fprintf(w, "  </script>\n")
        fmt.Fprintf(w, "  <script type=\"application/javascript\" src=\"https://api.ipify.org?format=jsonp&callback=getIP\"></script>\n")
        fmt.Fprintf(w, "  <div id=\"container\"></div>")
        fmt.Fprintf(w, "  <h3>Fingerprintjs2</h3>")
        fmt.Fprintf(w, "  <p>Your browser fingerprint: <strong id=\"fp\"></strong></p>")
        fmt.Fprintf(w, "  <p><code id=\"time\"/></p>")
        fmt.Fprintf(w, "  <p><span id=\"details\"/></p>")
        fmt.Fprintf(w, "  <button type=\"button\" id=\"btn\">Get my fingerprint</button>")

        fmt.Fprintf(w, "  <script src=\"include/fingerprint2.js\"></script>")
        fmt.Fprintf(w, "  <script>")
        fmt.Fprintf(w, "    document.querySelector(\"#btn\").addEventListener(\"click\", function () {")
        fmt.Fprintf(w, "      var d1 = new Date();")
        fmt.Fprintf(w, "      var fp = new Fingerprint2();")
        fmt.Fprintf(w, "      fp.get(function(result, components) {")
        fmt.Fprintf(w, "        var d2 = new Date();")
        fmt.Fprintf(w, "        var timeString = \"Time took to calculate the fingerprint: \" + (d2 - d1) + \"ms\";")
        fmt.Fprintf(w, "        var details = \"<strong>Detailed information: </strong><br />\";")
        fmt.Fprintf(w, "        if(typeof window.console !== \"undefined\") {")
        fmt.Fprintf(w, "          console.log(timeString);")
        fmt.Fprintf(w, "          console.log(result);")
        fmt.Fprintf(w, "          for (var index in components) {")
        fmt.Fprintf(w, "            var obj = components[index];")
        fmt.Fprintf(w, "            var value = obj.value;")
        fmt.Fprintf(w, "            var line = obj.key + \" = \" + value.toString().substr(0, 100);")
        fmt.Fprintf(w, "            console.log(line);")
        fmt.Fprintf(w, "            details += line + \"<br />\";")
        fmt.Fprintf(w, "          }")
        fmt.Fprintf(w, "        }")
        fmt.Fprintf(w, "        document.querySelector(\"#details\").innerHTML = details")
        fmt.Fprintf(w, "        document.querySelector(\"#fp\").textContent = result")
        fmt.Fprintf(w, "        document.querySelector(\"#time\").textContent = timeString")
        fmt.Fprintf(w, "      });")
        fmt.Fprintf(w, "    });")
        fmt.Fprintf(w, "  </script>")
        fmt.Fprintf(w, "  </body>\n")
        fmt.Fprintf(w, "</html>\n")
    }

    func main() {
        var err error
        rand.Seed(time.Now().UnixNano())
        log.Println("starting go echo service")
        samhost := flag.String("samhost", "sam-host", "host of the SAM to use")
        samport := flag.String("samport", "7656", "port of the SAM to use")
        host := flag.String("host", "0.0.0.0", "host to forward")
        port := flag.String("port", "9777", "port to forward")
        flag.Parse()
        if forwarder, err = samforwarder.NewSAMForwarderFromOptions(
            samforwarder.SetSaveFile(true),
            samforwarder.SetName("collude-"+randSeq(4)),
            samforwarder.SetSAMHost(*samhost),
            samforwarder.SetSAMPort(*samport),
            samforwarder.SetHost(*host),
            samforwarder.SetPort(*port),
        ); err != nil {
            log.Fatal(err.Error())
        } else {
            go forwarder.Serve()
        }
        log.Println("Colluder configured on:", forwarder.Base32())
        log.Fatal(http.ListenAndServe(*host+":"+*port, &blah{}))
    }


</code></pre>

<h2>An experimental solution that can exist outside of core i2p</h2>

<p>The obvious answer to this problem is to alter the http proxy to generate a
new destination for every eepsite it visits. But it would add bloat and it's
actually more in-scope for an external application using i2p's SAMv3 API to
generate tunnels on the fly. Which is why I'm building and using(dogfooding)
si-i2p-plugin, who's source code is available on github at
https://github.com/eyedeekay/si-i2p-plugin. It presents an http proxy on port
4443, which generates a new i2p destination for each i2p destination it has to
retrieve. It then routes all requests to that eepSite through that tunnel and
forwards it to the new http proxy, thereby providing some automatic isolation of
contextual identities. Keep in mind, my approach is experimental, which is why
this site exists. I am actively using these sites to test this software. I am
not conducting an attack, at least not on anyone else.</p>

<p>In addition to the http proxy, it provides a file-based management interface
for the tunnels it creates. for more information, see the github repo for now,
and eventually an eepSite which I'll link here when I put it up.</p>

</body>
